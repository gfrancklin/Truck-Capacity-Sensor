#include "stdint.h"
#include "stdio.h"

#define	CLEAR_BIT_0			0xFE
#define	SET_BIT_0			0x01
#define RX_BUFFER_SIZE		2
#define	MAX_ATTEMPTS		3
#define READ_RANGE_CMD		0x51
#define ADDR_UNLOCK_1_CMD	0xAA
#define ADDR_UNLOCK_2_CMD	0xA5
#define TX_BUFFER_SIZE		1
#define TIMEOUT_MS			1000
#define MAX_ADDR_VALUE		0xFF

extern I2C_HandleTypeDef hi2c1;

static int32_t i2cxl_maxsonar_measure(int);
static int32_t i2cxl_maxsonar_read(int, int *);

int32_t i2cxl_maxsonar_start(int addr, int * range_cm) {
	int32_t ret_val = 0;

	/* If some error occur it will set or clear the MSB to flag weather error
	 * in measurement or reading */
	if((ret_val = i2cxl_maxsonar_measure(addr)) != 0) {
		ret_val |= 0x80;
	} else if((ret_val = i2cxl_maxsonar_read(addr, range_cm)) != 0) {
		ret_val &= 0x7F;
	}
	return ret_val;
}

static int32_t i2cxl_maxsonar_measure(int addr) {
	int32_t ret_val = 0;
	uint8_t tx_cmd = READ_RANGE_CMD;
	uint8_t retry_times = 0;

	if(addr > MAX_ADDR_VALUE) {	//the address can't be higher than 255
		ret_val = -1;
	} else {
		addr = addr & CLEAR_BIT_0;
		while((ret_val != HAL_OK) | (retry_times < MAX_ATTEMPTS)) {
			retry_times++;
			ret_val = HAL_I2C_Master_Transmit(&hi2c1, (uint16_t)addr, &tx_cmd, sizeof(tx_cmd), TIMEOUT_MS);
		}
		if(retry_times == MAX_ATTEMPTS) {
			ret_val = -2;
		}
	}
	return ret_val;
}

static int32_t i2cxl_maxsonar_read(int addr, int * range_cm) {
	int32_t ret_val = 0;
	uint8_t rx_buffer[RX_BUFFER_SIZE] = {0};
	uint8_t retry_times = 0;

	if(addr > MAX_ADDR_VALUE) {	//the address can't be higher than 255
		ret_val = -1;
	} else {
		addr = addr | SET_BIT_0;	//set bit 0 to start reading

		/* Try to communicate for three times */
		while((ret_val != HAL_OK) | (retry_times < MAX_ATTEMPTS)) {
			retry_times++;
			ret_val = HAL_I2C_Master_Receive(&hi2c1, (uint16_t)addr, &rx_buffer, RX_BUFFER_SIZE, TIMEOUT_MS);
		}
		if(retry_times == MAX_ATTEMPTS) {
			ret_val = -2;
		} else {
			*range_cm = (rx_buffer[0] << 8) | rx_buffer[1];
		}
	}
	return ret_val;
}

int32_t change_addr(int old_addr, int * new_addr) {
	int32_t ret_val = 0;
	uint32_t retry_times = 0;
	uint8_t tx_cmd = ADDR_UNLOCK_1_CMD;

	if((old_addr > MAX_ADDR_VALUE) | (new_addr > MAX_ADDR_VALUE)) {	//the address can't be higher than 255
		ret_val = -1;
	} else if((new_addr == 0x00) | (new_addr == 80) | (new_addr == 164) | (new_addr == 170)) {
		ret_val = -2;
	} else {
		if((*new_addr % 2) == 1) {
			*new_addr = *new_addr - 1;
		}
		old_addr = old_addr & CLEAR_BIT_0;

		while((ret_val != HAL_OK) | (retry_times < MAX_ATTEMPTS)) {
			retry_times++;
			ret_val = HAL_I2C_Master_Transmit(&hi2c1, (uint16_t)old_addr, &tx_cmd, sizeof(tx_cmd), TIMEOUT_MS);
			if(ret_val == HAL_OK) {
				tx_cmd = ADDR_UNLOCK_2_CMD;
				ret_val = HAL_I2C_Master_Transmit(&hi2c1, (uint16_t)old_addr, &tx_cmd, sizeof(tx_cmd), TIMEOUT_MS);
				if(ret_val == HAL_OK) {
					ret_val = HAL_I2C_Master_Transmit(&hi2c1, (uint16_t)old_addr, new_addr, sizeof(new_addr), TIMEOUT_MS);
				}
			}
		}
		if(retry_times == MAX_ATTEMPTS) {
			ret_val = -2;
		} else {
			ret_val = HAL_I2C_IsDeviceReady(&hi2c1, *(uint16_t *)new_addr, MAX_ATTEMPTS, TIMEOUT_MS);
		}
	}
	return ret_val;
}
